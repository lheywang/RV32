#!/usr/bin/env python3
"""
Generate SystemVerilog and C++ enum definitions from a simple definition file.
"""

import argparse
import importlib.util
import datetime
import tomllib
from pathlib import Path


def generate_SV(keys: dict, includes: list[Path], outfile: Path):

    with open(outfile, "w+") as f:
        # Append header
        f.write(
            f"""/*
 *  File :      {str(outfile)}
 *
 *  Author :    Generated by {__file__.split("/")[-1]}
 *  Date :      {datetime.datetime.now()}
 *  
 *  Brief :     This file define the {outfile.name.split(".")[0]} package, 
 *              which contain definitions from different configs/ files (.toml and .py)
 */
"""
        )

        # Append global syntax
        f.write(f"\n`timescale 1ns / 1ps\n")  # To make verilator happy

        # Append the core package def
        f.write(f"\npackage {outfile.name.split(".")[0]};\n\n")
        f.write("    /* verilator lint_off UNUSEDPARAM */\n")

        # Add any keys into the file :
        for key, value in keys.items():

            # Check if we have a list or any elements :
            if isinstance(value, list):

                f.write(f"    parameter int {key.upper()}[{len(value)}] = '{{\n")
                for index, val in enumerate(value):
                    f.write(f"        {int(val)}")

                    if index != len(value) - 1:
                        f.write(",\n")
                    else:
                        f.write("\n")

                f.write("    };\n")

            else:

                f.write(f"    parameter int {key.upper()} = {int(value)};\n")

        # Append includes
        f.write("\n\n    // Included files : \n")
        for include in includes:
            f.write(f'    `include "{include}"\n')

        # Append the endmodule
        f.write("    /* verilator lint_on UNUSEDPARAM */\n")
        f.write("\nendpackage\n")


def generate_C(keys: dict, includes: list[Path], outfile: Path):

    with open(outfile, "w+") as f:
        # Append header
        f.write(
            f"""/*
 *  File :      {str(outfile)}
 *
 *  Author :    Generated by {__file__.split("/")[-1]}
 *  Date :      {datetime.datetime.now()}
 *  
 *  Brief :     This file define the {outfile.name.split(".")[0]} values as constexpr, 
 *              which contain definitions from different configs/ files (.toml and .py)
 */
"""
        )

        # Append global syntax
        f.write(f"\n#ifndef __DEF_{outfile.name.split(".")[0].upper()}_\n")  # To make gcc happy
        f.write(f"#define __DEF_{outfile.name.split(".")[0].upper()}_\n\n")

        # Append includes
        for include in includes:
            f.write(f'#include "{include}"\n')
        f.write("\n")

        # Add any keys into the file :
        for key, value in keys.items():

            # Check if we have a list or any elements :
            if isinstance(value, list):

                f.write(f"constexpr unsigned int {key.upper()}[{len(value)}] = {{\n")
                for index, val in enumerate(value):
                    f.write(f"    {int(val)}")

                    if index != len(value) - 1:
                        f.write(",\n")
                    else:
                        f.write("\n")

                f.write("};\n")

            else:

                f.write(f"constexpr unsigned int {key.upper()} = {int(value)};\n")

        # Append the endmodule
        f.write(f"\n#endif")


def generate_C_includes(includes: list[Path], outfile: Path):

    if not outfile.exists():

        with open(outfile, "w+") as f:
            # Append header
            f.write(
                f"""/*
*  File :      {str(outfile)}
*
*  Author :    Generated by {__file__.split("/")[-1]}
*  Date :      {datetime.datetime.now()}
*  
*  Brief :     This file include any generated files into a single one, which can be hardcoded
*/\n
"""
            )

            # Append includes
            for include in includes:
                f.write(f'#include "{include.name}"\n')

    else:

        with open(outfile, "a") as f:

            for include in includes:
                f.write(f'#include "{include.name}"\n')


def generate_SV_includes(includes: list[Path], outfile: Path):

    if not outfile.exists():

        with open(outfile, "w+") as f:
            # Append header
            f.write(
                f"""/*
*  File :      {str(outfile)}
*
*  Author :    Generated by {__file__.split("/")[-1]}
*  Date :      {datetime.datetime.now()}
*  
*  Brief :     This file include any generated files into a single one, which can be hardcoded
*/\n
"""
            )
            f.write(f"\n`timescale 1ns / 1ps\n\n")  # To make verilator happy

            # Append includes
            for include in includes:
                f.write(f'`include "{include.name}"\n')

    else:

        with open(outfile, "a") as f:

            # Append includes
            for include in includes:
                f.write(f'`include "{include.name}"\n')


def apply_script(config: dict, script_path: Path) -> dict:
    """Dynamically import and apply a config script."""
    spec = importlib.util.spec_from_file_location(script_path.stem, script_path)
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)

    if hasattr(module, "apply"):
        print(f"Running script {script_path} ...")
        return module.apply(config)
    else:
        raise AttributeError(f"{script_path} has no 'apply(config)' function")


def main():
    parser = argparse.ArgumentParser(
        description="Generate SystemVerilog and C++ enum definitions from a simple definition file (toml)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "config_folder",
        metavar="FOLDER",
        help="Location of the config file name and scripts. Any TOML files will be loaded all together",
    )

    parser.add_argument(
        "-o",
        "--output",
        default="build/",
        metavar="FILE",
        help="Output files location",
    )
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")

    args = parser.parse_args()

    # List all sources and scripts files
    p = Path(args.config_folder).glob("**/*.toml")
    configs = [x for x in p if x.is_file()]

    p = Path(args.config_folder).glob("**/*.py")
    scripts = [x for x in p if x.is_file()]

    p = Path(args.config_folder).glob("**/includes.toml")
    includes = [x for x in p if x.is_file()]

    # Removing the includes files from the config files
    configs = list(set(configs) - set(includes))

    # Read all of the elements into the configs files, and flatten the dicts
    keys = dict()
    for config in configs:
        with open(config, "rb") as f:
            tmp = tomllib.load(f)
            for key in tmp.keys():
                keys = keys | tmp[key]

    inc = dict()
    for include in includes:
        with open(include, "rb") as f:
            tmp = tomllib.load(f)
            for key in tmp.keys():
                inc = inc | tmp[key]
    inc = list(inc.keys())
    # Generate C include files
    incC = [val.split(".")[0] + ".h" for val in inc]

    # Then, call the different subscripts to generate the computed keys
    for script in scripts:
        apply_script(keys, script)

    # Get the folder name
    dirname = Path(args.config_folder).name

    # Generate file names
    SVfile = Path(args.output) / Path(f"{dirname}_config_pkg.svh")
    Cfile = Path(args.output) / Path(f"generated_{dirname}_config_pkg.h")
    incCfile = Path(args.output) / Path(f"generated.h")
    incSVfile = Path(args.output) / Path(f"generated.sv")

    # Finally, generate the right files :
    generate_SV(keys, inc, SVfile)
    generate_C(keys, incC, Cfile)

    # Generate the C include file
    generate_C_includes([Cfile], incCfile)
    generate_SV_includes([SVfile], incSVfile)


if __name__ == "__main__":
    main()
