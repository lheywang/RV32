#!/usr/bin/env python3
"""
Generate SystemVerilog and C++ enum definitions from a simple definition file.

Definition file format:
    # Comments start with #

    [EnumName]
    type = logic[6:0]  # Optional: SV type, defaults to logic[31:0]
    VALUE1 = 0b1010
    VALUE2 = 0x0F
    VALUE3 = 42
    VALUE4          # Auto-increment from previous

    [AnotherEnum]
    ITEM1 = 0
    ITEM2           # Auto = 1
    ITEM3 = 5
"""

import argparse
import re
import sys
from pathlib import Path


def parse_value(value_str, auto_value):
    """Parse a value string (binary, hex, decimal) or return auto-incremented value."""
    if value_str is None or value_str.strip() == "":
        return auto_value

    value_str = value_str.strip()

    # Binary: 0b1010 or 1010
    if value_str.startswith("0b"):
        return int(value_str[2:], 2)
    elif all(c in "01" for c in value_str):
        return int(value_str, 2)

    # Hex: 0x0F
    if value_str.startswith("0x") or value_str.startswith("0X"):
        return int(value_str, 16)

    # Decimal
    try:
        return int(value_str, 0)  # Handles 0x, 0b, 0o automatically
    except ValueError:
        raise ValueError(f"Cannot parse value: {value_str}")


def format_sv_value(value, bit_width):
    """Format value for SystemVerilog with proper bit width."""
    return f"{bit_width}'h{hex(value)[2:]}"


def format_cpp_value(value):
    """Format value for C++."""
    return f"0x{value:08X}"


def parse_enum_file(filepath):
    """Parse the enum definition file."""
    enums = []
    current_enum = None

    with open(filepath, "r") as f:
        for line_no, line in enumerate(f, 1):
            line = line.strip()

            # Skip empty lines and comments
            if not line or line.startswith("#"):
                continue

            # New enum definition
            if line.startswith("[") and line.endswith("]"):
                if current_enum:
                    enums.append(current_enum)

                enum_name = line[1:-1].strip()
                current_enum = {
                    "name": enum_name,
                    "type": "logic [31:0]",  # Default type
                    "values": [],
                    "line": line_no,
                }
                continue

            if not current_enum:
                raise ValueError(f"Line {line_no}: Value definition outside of enum block")

            # Type specification
            if line.startswith("type"):
                match = re.match(r"type\s*=\s*(.+)", line)
                if match:
                    current_enum["type"] = match.group(1).strip()
                continue

            # Value definition
            match = re.match(r"(\w+)\s*(?:=\s*(.+))?", line)
            if match:
                name = match.group(1)
                value_str = match.group(2)

                # Auto-increment from last value
                auto_value = (
                    0 if not current_enum["values"] else current_enum["values"][-1]["value"] + 1
                )

                try:
                    value = parse_value(value_str, auto_value)
                except ValueError as e:
                    raise ValueError(f"Line {line_no}: {e}")

                current_enum["values"].append({"name": name, "value": value})

    if current_enum:
        enums.append(current_enum)

    return enums


def extract_bit_width(sv_type):
    """Extract bit width from SystemVerilog type like 'logic [6:0]'."""
    match = re.search(r"\[(\d+):(\d+)\]", sv_type)
    if match:
        high = int(match.group(1))
        low = int(match.group(2))
        return high - low + 1
    return None  # Will be auto-calculated


def calculate_required_bits(max_value):
    """Calculate minimum number of bits needed to represent a value."""
    if max_value == 0:
        return 1
    bits = max_value.bit_length()
    return bits


def generate_systemverilog(enums, output_path):
    """Generate SystemVerilog package file."""
    lines = [
        "// AUTO-GENERATED FILE - DO NOT EDIT",
        f"// Generated by {__file__.split("/")[-1]}",
        "",
    ]

    for enum in enums:
        # Get explicit bit width or calculate from max value
        explicit_width = extract_bit_width(enum["type"])

        if explicit_width is not None:
            bit_width = explicit_width
            sv_type = enum["type"]
        else:
            # Auto-calculate based on maximum value
            max_value = max(val["value"] for val in enum["values"])
            bit_width = calculate_required_bits(max_value)
            sv_type = f"logic [{bit_width-1}:0]"

        lines.append(f"typedef enum {sv_type} {{")

        for i, val in enumerate(enum["values"]):
            comma = "," if i < len(enum["values"]) - 1 else ""
            sv_val = format_sv_value(val["value"], bit_width)
            lines.append(f"    {val['name']: <20} = {sv_val}{comma}")

        lines.append(f"}} {enum['name']};")
        lines.append("")

    with open(output_path, "w") as f:
        f.write("\n".join(lines))


def generate_cpp(enums, output_path):
    """Generate C++ header file."""
    lines = [
        "// AUTO-GENERATED FILE - DO NOT EDIT",
        f"// Generated by {__file__.split("/")[-1]}",
        "",
        f"#ifndef _{output_path.split("/")[-1].split(".")[0].upper()}_H",
        f"#define _{output_path.split("/")[-1].split(".")[0].upper()}_H",
        "",
        "#include <cstdint>",
        "",
    ]

    for enum in enums:
        # Creating the whole opcode enum
        lines.append(f"typedef enum {{")

        for i, val in enumerate(enum["values"]):
            comma = "," if i < len(enum["values"]) - 1 else ""
            cpp_val = format_cpp_value(val["value"])
            lines.append(f"    {val['name']: <20} = {cpp_val}{comma}")

        lines.append(f"}} {enum['name']};")
        lines.append("")

        # Appending a function to make a lookup-table function
        lines.append(f"static const std::string __{enum['name']}_names[{len(enum["values"])}] = {{")

        for i, val in enumerate(enum["values"]):
            comma = "," if i < len(enum["values"]) - 1 else ""
            lines.append(f"    \"{val['name'][2:]}\"{comma}")
        lines.append("};\n")

        # Appending the function that'll make the lookup
        lines.append(f"inline const std::string get_name({enum["name"]} op)")
        lines.append("{")
        lines.append(f"    return __{enum['name']}_names[static_cast<int>(op)];")
        lines.append("}")

    lines.append(f"\n#endif // _{output_path.split("/")[-1].split(".")[0].upper()}_H")

    with open(output_path, "w") as f:
        f.write("\n".join(lines))


def main():
    parser = argparse.ArgumentParser(
        description="Generate SystemVerilog and C++ enum definitions from a simple definition file.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Example definition file format:
  # Comments start with #
  
  [EnumName]
  type = logic[6:0]  # Optional: SV type. If omitted, auto-calculated from max value
  VALUE1 = 0b1010
  VALUE2 = 0x0F
  VALUE3 = 42
  VALUE4          # Auto-increment from previous
  
  [AnotherEnum]
  # No type specified - will auto-calculate bit width
  ITEM1           # Starts at 0
  ITEM2           # Auto = 1
  ITEM3 = 5       # Jump to 5
  ITEM4           # Auto = 6

Usage example:
  %(prog)s opcodes.def -s opcodes.svh -c opcodes.h
        """,
    )

    parser.add_argument("definition_file", help="Input definition file")
    parser.add_argument(
        "-s",
        "--systemverilog",
        default="generated_enums.svh",
        metavar="FILE",
        help="SystemVerilog output file (default: generated_enums.svh)",
    )
    parser.add_argument(
        "-c",
        "--cpp",
        default="generated_enums.h",
        metavar="FILE",
        help="C++ output file (default: generated_enums.h)",
    )
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")

    args = parser.parse_args()

    try:
        enums = parse_enum_file(args.definition_file)

        if args.verbose:
            print(f"Parsed {len(enums)} enum(s) from {args.definition_file}")
            for enum in enums:
                print(f"  - {enum['name']}: {len(enum['values'])} values")

        generate_systemverilog(enums, args.systemverilog)
        generate_cpp(enums, args.cpp)

    except FileNotFoundError:
        print(f"Error: File not found: {args.definition_file}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
