#include "Vpcounter.h" // Generated by Verilator
#include "verilated.h"
#include "verilated_vcd_c.h"
#include <iostream>
#include <iomanip>
#include "utils/colors.h"

// Simulation time
vluint64_t sim_time = 0;
int clkdiv;

// Toggle clock helper
void tick(Vpcounter *tb, VerilatedVcdC *tfp)
{
    tb->clk = 0;
    tb->eval();
    tfp->dump(sim_time++);
    tb->clk = 1;
    tb->eval();
    tfp->dump(sim_time++);
}

// Main
int main(int argc, char **argv)
{
    Verilated::commandArgs(argc, argv);

    // Instantiate model
    Vpcounter *tb = new Vpcounter;

    // Setup waveform tracing
    Verilated::traceEverOn(true);
    VerilatedVcdC *tfp = new VerilatedVcdC;
    tb->trace(tfp, 99);
    tfp->open("simout/pcounter.vcd");

    // Reset sequence
    tb->rst_n = 0;
    tb->clk_en = 1;
    tb->enable = 0;
    tb->load = 0;
    tb->loaded = 0x10000000;
    tick(tb, tfp);

    tb->rst_n = 1;
    tick(tb, tfp);

    std::cout << KMAG
              << "Starting counter simulation...\n"
              << RST;

    int pass = 0;
    int fail = 0;

    // --- Test 1: Count until overflow ---
    for (int i = 0; i < 4095; i++)
    {
        tb->enable = 1;
        tick(tb, tfp);

        tb->loaded += 4;

        if (tb->address == tb->loaded)
        {
            pass += 1;
        }
        else
        {
            std::cout << KRED
                      << "\t[ FAIL ] Cycle "
                      << std::hex
                      << std::setw(4) << i
                      << " addr : "
                      << tb->address
                      << " waited : "
                      << tb->loaded
                      << RST
                      << std::endl;
            fail += 1;
        }
    }

    // --- Test 2: Load a new address ---
    tb->enable = 0;
    tb->load = 1;
    tb->loaded = 0x10003FF0;
    int ovf[4] = {0, 0, 0, 1};
    tick(tb, tfp);

    tb->load = 0;
    tb->enable = 1;
    for (int i = 0; i < 4; i++)
    {
        tick(tb, tfp);

        if (i != 3)
            tb->loaded += 4;

        if ((tb->address == tb->loaded) & ((int)tb->ovf == ovf[i]))
        {
            pass += 1;
        }
        else
        {
            std::cout << KRED
                      << "\t[ FAIL ] Cycle "
                      << std::hex
                      << std::setw(4) << i
                      << " addr : "
                      << tb->address
                      << " waited : "
                      << tb->loaded
                      << " ovf : "
                      << (int)tb->ovf
                      << " waiting : "
                      << ovf[i]
                      << RST
                      << std::endl;
            fail += 1;
        }
    }

    tfp->close();
    delete tb;
    return fail;
}
