#include "Valu0.h" // Generated by Verilator
#include "verilated.h"
#include "verilated_vcd_c.h"
#include <iostream>
#include <iomanip>
#include "utils/colors.h"
#include "utils/utils.h"

// Simulation time
vluint64_t sim_time = 0;

// Toggle clock helper
void tick(Valu0 *tb, VerilatedVcdC *tfp)
{
    tb->clk = !tb->clk;
    tb->eval();
    tfp->dump(sim_time++);
}

unsigned int inputs1[5] = {10, 32, 48, 64, 1024};
unsigned int inputs2[5] = {0x7FFFF000, 4096, 0xAAAAAAAA, 0x55555555, 0};

// Main
int main(int argc, char **argv)
{
    Verilated::commandArgs(argc, argv);

    // Instantiate model
    Valu0 *tb = new Valu0;

    // Setup waveform tracing
    Verilated::traceEverOn(true);
    VerilatedVcdC *tfp = new VerilatedVcdC;
    tb->trace(tfp, 99);
    tfp->open("simout/alu0.vcd");

    // Reset sequence
    tb->rst_n = 0;
    tick(tb, tfp);
    tb->rst_n = 1;
    tick(tb, tfp);
    tick(tb, tfp);
    tick(tb, tfp);

    std::cout << KMAG
              << "Starting ALU simulation...\n"
              << RST;

    int pass = 0;
    int fail = 0;
    int cycle;

    // Formal calculation test
    for (int i = 0; i < 5; i++)
    {
        tb->cmd = i;
        tb->i_rd = 0x1F;

        for (int ii = 0; ii < 5; ii++)
        {
            for (int iii = 0; iii < 5; iii++)
            {
                cycle += 1;
                tb->arg0 = inputs1[ii];
                tb->arg1 = inputs2[iii];
                tick(tb, tfp);
                tick(tb, tfp);
                tick(tb, tfp);
                tick(tb, tfp);
                if (tb->busy != 1)
                    fail += 1;
                else
                    pass += 1;
                if (tb->valid != 1)
                    fail += 1;
                else
                    pass += 1;
                if (tb->o_rd != 0x1F)
                    fail += 1;
                else
                    pass += 1;

                switch (i)
                {
                case 0: // ADD
                    if (tb->res != (inputs1[ii] + inputs2[iii]))
                    {
                        std::cout << KRED
                                  << "[ FAIL ] Cycle "
                                  << std::hex
                                  << std::setw(4) << cycle
                                  << std::endl
                                  << "    OP  : " << std::setw(8) << inputs1[ii] << " + " << std::setw(8) << inputs2[iii] << std::endl
                                  << "    GOT : " << std::setw(8) << tb->res << std::endl
                                  << RST
                                  << std::endl;
                        fail += 1;
                    }
                    else
                    {
                        std::cout << KGRN
                                  << "\t[ PASS ] Cycle "
                                  << std::hex
                                  << std::setw(4) << cycle
                                  << RST
                                  << std::endl;
                        pass += 1;
                    }
                    break;

                case 1: // SUB
                    if (tb->res != (inputs1[ii] - inputs2[iii]))
                    {
                        std::cout << KRED
                                  << "[ FAIL ] Cycle "
                                  << std::hex
                                  << std::setw(4) << cycle
                                  << std::endl
                                  << "    OP  : " << std::setw(8) << inputs1[ii] << " - " << std::setw(8) << inputs2[iii] << std::endl
                                  << "    GOT : " << std::setw(8) << tb->res << std::endl
                                  << RST
                                  << std::endl;
                        fail += 1;
                    }
                    else
                    {
                        std::cout << KGRN
                                  << "\t[ PASS ] Cycle "
                                  << std::hex
                                  << std::setw(4) << cycle
                                  << RST
                                  << std::endl;
                        pass += 1;
                    }
                    break;

                case 2: // AND
                    if (tb->res != (inputs1[ii] & inputs2[iii]))
                    {
                        std::cout << KRED
                                  << "[ FAIL ] Cycle "
                                  << std::hex
                                  << std::setw(4) << cycle
                                  << std::endl
                                  << "    OP  : " << std::setw(8) << inputs1[ii] << " & " << std::setw(8) << inputs2[iii] << std::endl
                                  << "    GOT : " << std::setw(8) << tb->res << std::endl
                                  << RST
                                  << std::endl;
                        fail += 1;
                    }
                    else
                    {
                        std::cout << KGRN
                                  << "\t[ PASS ] Cycle "
                                  << std::hex
                                  << std::setw(4) << cycle
                                  << RST
                                  << std::endl;
                        pass += 1;
                    }
                    break;

                case 3: // OR
                    if (tb->res != (inputs1[ii] | inputs2[iii]))
                    {
                        std::cout << KRED
                                  << "[ FAIL ] Cycle "
                                  << std::hex
                                  << std::setw(4) << cycle
                                  << std::endl
                                  << "    OP  : " << std::setw(8) << inputs1[ii] << " | " << std::setw(8) << inputs2[iii] << std::endl
                                  << "    GOT : " << std::setw(8) << tb->res << std::endl
                                  << RST
                                  << std::endl;
                        fail += 1;
                    }
                    else
                    {
                        std::cout << KGRN
                                  << "\t[ PASS ] Cycle "
                                  << std::hex
                                  << std::setw(4) << cycle
                                  << RST
                                  << std::endl;
                        pass += 1;
                    }
                    break;

                case 4: // XOR
                    if (tb->res != (inputs1[ii] ^ inputs2[iii]))
                    {
                        std::cout << KRED
                                  << "[ FAIL ] Cycle "
                                  << std::hex
                                  << std::setw(4) << cycle
                                  << std::endl
                                  << "    OP  : " << std::setw(8) << inputs1[ii] << " ^ " << std::setw(8) << inputs2[iii] << std::endl
                                  << "    GOT : " << std::setw(8) << tb->res << std::endl
                                  << RST
                                  << std::endl;
                        fail += 1;
                    }
                    else
                    {
                        std::cout << KGRN
                                  << "\t[ PASS ] Cycle "
                                  << std::hex
                                  << std::setw(4) << cycle
                                  << RST
                                  << std::endl;
                        pass += 1;
                    }
                    break;
                }

                tb->clear = 1;
            }
        }
    }

    // Overflow test
    tb->cmd = 0;
    tb->i_rd = 0x1F;
    tb->arg0 = 0xFFFFFFFF;
    tb->arg1 = 0xFFFFFFFF;
    tick(tb, tfp);
    tick(tb, tfp);
    tick(tb, tfp);
    tick(tb, tfp);

    if (tb->o_error != 1)
    {
        fail += 1;
    }
    else
    {
        pass += 1;
    }

    final_print(pass, fail, "ALU0");

    tfp->close();
    delete tb;
    return fail;
}
