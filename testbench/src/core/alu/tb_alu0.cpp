#include "Valu0.h" // Generated by Verilator
#include "verilated.h"

#include "testbench.h"

unsigned int inputs1[5] = {10, 32, 48, 64, 1024};
unsigned int inputs2[5] = {0x7FFFF000, 4096, 0xAAAAAAAA, 0x55555555, 0};

// Main
int main(int argc, char **argv)
{
    Verilated::commandArgs(argc, argv);
    Testbench<Valu0> tb("ALU0");
    tb.reset();

    int cycle = 0;

    // Formal calculation test
    for (int i = alu_commands_t::c_ADD; i < (alu_commands_t::c_XOR + 1); i++)
    {
        tb.dut->cmd = i;
        tb.dut->i_rd = 0x1F;

        switch (i)
        {
        case alu_commands_t::c_ADD : 
            tb.set_case("ADD");
            break;
        case alu_commands_t::c_SUB : 
            tb.set_case("SUB");
            break;
        case alu_commands_t::c_AND : 
            tb.set_case("AND");
            break;
        case alu_commands_t::c_OR : 
            tb.set_case("OR");
            break;
        case alu_commands_t::c_XOR : 
            tb.set_case("XOR");
            break;
        }

        for (int ii = 0; ii < 5; ii++)
        {
            for (int iii = 0; iii < 5; iii++)
            {
                tb.dut->arg0 = inputs1[ii];
                tb.dut->arg1 = inputs2[iii];
                tb.tick();
                tb.tick();

                tb.check_equality((unsigned int)tb.dut->busy, (unsigned int)1, "busy");
                tb.check_equality((unsigned int)tb.dut->valid, (unsigned int)1, "valid");
                tb.check_equality((unsigned int)tb.dut->o_rd, (unsigned int)0x1F, "o_rd");

                switch (i)
                {
                case alu_commands_t::c_ADD : 
                    tb.check_equality((unsigned int)tb.dut->res, (unsigned int)(inputs1[ii] + inputs2[iii]), "res");
                    break;

                case alu_commands_t::c_SUB : 
                    tb.check_equality((unsigned int)tb.dut->res, (unsigned int)(inputs1[ii] - inputs2[iii]), "res");
                    break;

                case alu_commands_t::c_AND : 
                    tb.check_equality((unsigned int)tb.dut->res, (unsigned int)(inputs1[ii] & inputs2[iii]), "res");
                    break;

                case alu_commands_t::c_OR : 
                    tb.check_equality((unsigned int)tb.dut->res, (unsigned int)(inputs1[ii] | inputs2[iii]), "res");
                    break;

                case alu_commands_t::c_XOR : 
                    tb.check_equality((unsigned int)tb.dut->res, (unsigned int)(inputs1[ii] ^ inputs2[iii]), "res");
                    break;
                }

                tb.dut->clear = 1;
                tb.increment_cycles();
            }
        }
    }

    // Overflow test
    tb.set_case("Overflow");
    tb.dut->cmd = 0;
    tb.dut->i_rd = 0x1F;
    tb.dut->arg0 = 0xFFFFFFFF;
    tb.dut->arg1 = 0xFFFFFFFF;

    tb.tick();
    tb.tick();

    tb.check_equality((unsigned int)tb.dut->o_error, (unsigned int)1, "Overflow");

    return tb.get_return();
}
