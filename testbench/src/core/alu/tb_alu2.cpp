#include "Valu2.h" // Generated by Verilator
#include "verilated.h"

#include "testbench.h"

char *module = (char *)"ALU2";

// Main
int main(int argc, char **argv)
{
    Verilated::commandArgs(argc, argv);
    Testbench<Valu2> tb("ALU2");
    tb.reset();
    /*
     *  Note : Since the major work of proving that the operation are working is done
     *  into the dedicated testbenches, we oly assert here that the signals from, and to
     *  this ALU are correct, more than performing a real computation test.
     */

    int opcodes[] = {alu_commands_t::c_MUL,
                     alu_commands_t::c_MULH,
                     alu_commands_t::c_MULHSU,
                     alu_commands_t::c_MULHU,
                     alu_commands_t::c_DIV,
                     alu_commands_t::c_DIVU,
                     alu_commands_t::c_REM,
                     alu_commands_t::c_REMU,
                     alu_commands_t::c_SLL,
                     alu_commands_t::c_SRL,
                     alu_commands_t::c_SRA};

    int val1 = 0xAAAAAAAA;
    int val2 = 2;

    unsigned int results[] = {0x55555554,
                              0x00000003,
                              0x00000003,
                              0x00000003,
                              0xD5555555,
                              0x55555555,
                              0x00000000,
                              0x00000000,
                              0xAAAAAAA8,
                              0x2AAAAAAA,
                              0xEAAAAAAA};

    int ticks = 0;

    for (int op = 0; op < 11; op++)
    {
        // Initial print for the case
        switch (opcodes[op])
        {
        case alu_commands_t::c_MUL:
            tb.set_case("MUL   ");
            // print_case(module, (char *)"MUL   ");
            break;
        case alu_commands_t::c_MULH:
            tb.set_case("MULH  ");
            // print_case(module, (char *)"MULH  ");
            break;
        case alu_commands_t::c_MULHSU:
            tb.set_case("MULHSU");
            // print_case(module, (char *)"MULHSU");
            break;
        case alu_commands_t::c_MULHU:
            tb.set_case("MULHU ");
            // print_case(module, (char *)"MULHU ");
            break;
        case alu_commands_t::c_DIV:
            tb.set_case("DIV   ");
            // print_case(module, (char *)"DIV   ");
            break;
        case alu_commands_t::c_DIVU:
            tb.set_case("DIVU  ");
            // print_case(module, (char *)"DIVU  ");
            break;
        case alu_commands_t::c_REM:
            tb.set_case("REM   ");
            // print_case(module, (char *)"REM   ");
            break;
        case alu_commands_t::c_REMU:
            tb.set_case("REMU  ");
            // print_case(module, (char *)"REMU  ");
            break;
        case alu_commands_t::c_SLL:
            tb.set_case("SLL   ");
            // print_case(module, (char *)"SLL   ");
            break;
        case alu_commands_t::c_SRL:
            tb.set_case("SRL   ");
            // print_case(module, (char *)"SRL   ");
            break;
        case alu_commands_t::c_SRA:
            tb.set_case("SRA   ");
            // print_case(module, (char *)"SRA   ");
            break;
        }

        // The usage of both tb.set and direct assignement work.
        tb.dut->cmd = opcodes[op];
        tb.dut->arg0 = val1;
        tb.dut->arg1 = val2;
        tb.dut->i_rd = 17;

        tb.tick();

        tb.dut->cmd = 0;
        tb.dut->arg0 = 0;
        tb.dut->arg1 = 0;
        tb.dut->i_rd = 0;

        // Wait to finish
        tb.run_until(&tb.dut->valid, 1);

        tb.check_equality((unsigned int)tb.dut->valid, (unsigned int)1, "valid");
        tb.check_equality((unsigned int)tb.dut->res, (unsigned int)results[op], "res");
        tb.check_equality((unsigned int)tb.dut->o_rd, (unsigned int)17, "o_rd");
        tb.check_equality((unsigned int)tb.dut->i_error, (unsigned int)0, "i_error");
        tb.check_equality((unsigned int)tb.dut->o_error, (unsigned int)0, "o_error");
        tb.check_equality((unsigned int)tb.dut->req, (unsigned int)0, "req");

        // Finally, clearing the output

        tb.dut->clear = 1;
        tb.tick();
        tb.dut->clear = 0;

        tb.check_equality((unsigned int)tb.dut->busy, (unsigned int)0, "busy");

        tb.increment_cycles();
    }

    return tb.get_return();
}
