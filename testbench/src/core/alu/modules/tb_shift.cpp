#include "Vshift.h" // Generated by Verilator
#include "verilated.h"

#include "testbench.h"

unsigned int input[20] = {10, 100, 1000, 0xFFFFFFFF, 0, 8, 2, 17, 29, 33, 59, 87, 453610452, 452135, 125245454, 47, 123, 789, 456, 20};

// Main
int main(int argc, char **argv)
{
    Verilated::commandArgs(argc, argv);
    Testbench<Vshift> tb("Shifter");
    tb.reset();

    for (int op = 0; op < 3; op++)
    {
        // select shift mode
        switch (op)
        {
        case 0:
            tb.dut->shift_left = 0;
            tb.dut->arithmetic = 0;
            tb.set_case("Right shift      ");
            break;
        case 1:
            tb.dut->shift_left = 0;
            tb.dut->arithmetic = 1;
            tb.set_case("Arithmetic shift ");
            break;
        case 2:
            tb.dut->shift_left = 1;
            tb.dut->arithmetic = 0;
            tb.set_case("Left shift");
            break;
            // Fourth combination is equivalent by hardware to case 2, thus, untested.
        }

        for (int i = 0; i < 20; i++)
        {
            tb.dut->data_in = input[i];

            for (int ii = 0; ii < 32; ii++)
            {
                tb.dut->shift_amount = ii;
                tb.dut->start = 1;
                tb.tick();
                tb.dut->start = 0;
                tb.run_until(&tb.dut->done, 1);

                switch (op)
                {
                case 0:
                    tb.check_equality(&tb.dut->data_out, (unsigned)tb.dut->data_in >> tb.dut->shift_amount, "Shifted");
                    break;
                case 1:
                    tb.check_equality(&tb.dut->data_out, (signed)tb.dut->data_in >> tb.dut->shift_amount, "Shifted");
                    break;
                case 2:
                    tb.check_equality(&tb.dut->data_out, (unsigned)tb.dut->data_in << tb.dut->shift_amount, "Shifted");
                    break;
                }

                tb.increment_cycles();
            }
        }
    }

    return tb.get_return();
}
