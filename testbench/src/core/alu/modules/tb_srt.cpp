#include "Vsrt.h" // Generated by Verilator
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>

#include "colors.h"
#include "utils.h"
#include "generated_commands.h"

char *module = (char *)"SRT-Divider";

unsigned int input1[20] = {10, 100, 1000, 0xFFFFFFFF, 0, 8, 2, 17, 29, 33, 59, 87, 453610452, 452135, 125245454, 47, 123, 789, 456, 20};
unsigned int input2[20] = {3, 5, 7, 9, 22, 0xFFFFFFFF, 21, 37, 49, 11345678, 0xAAAAAAAA, 0x55555555, 456, 123, 789, 741, 852, 963, 0, 123};

// Main
int main(int argc, char **argv)
{
    Verilated::commandArgs(argc, argv);

    // Instantiate model
    Vsrt *tb = new Vsrt;

    // Setup waveform tracing
    Verilated::traceEverOn(true);
    VerilatedVcdC *tfp = new VerilatedVcdC;
    tb->trace(tfp, 99);
    tfp->open("simout/srt.vcd");

    // Reset sequence
    stick(tb, tfp);
    tb->rst_n = 0;
    tb->clk = 0;
    tick(tb, tfp);
    tick(tb, tfp);

    tb->rst_n = 1;
    tick(tb, tfp);

    initial_print(module);

    int ticks = 0;

    for (int op = 0; op < 2; op++)
    {
        switch (op)
        {
        case 0:
            tb->dividend_signed = 0;
            tb->divisor_signed = 0;
            print_case(module, (char *)"Unsigned X Unsigned");
            break;
        case 1:
            tb->dividend_signed = 1;
            tb->divisor_signed = 1;
            print_case(module, (char *)"  Signed X   Signed");
            break;
        }

        // First set of inputs
        for (int i = 0; i < 20; i++)
        {
            for (int ii = 0; ii < 20; ii++)
            {
                // Set inputs
                tb->dividend = input1[i];
                tb->divisor = input2[ii];

                // Start the test
                stick(tb, tfp);
                tb->start = 1;
                stick(tb, tfp);

                if (tb->divisor == 0)
                {

                    // Let the testbench compute
                    do
                    {
                        tick(tb, tfp);
                        tb->start = 0;
                    } while (tb->valid != 1);

                    equality_print((char *)"Valid         ",
                                   ticks,
                                   tb->valid,
                                   1);
                    equality_print((char *)"Div By Zero   ",
                                   ticks,
                                   tb->div_by_zero,
                                   1);

                    equality_print((char *)"Result (Null )",
                                   ticks,
                                   tb->quotient,
                                   0xFFFFFFFF);
                }
                else
                {
                    // Let the testbench compute
                    do
                    {
                        tick(tb, tfp);
                        tb->start = 0;
                    } while (tb->valid != 1);

                    equality_print((char *)"Valid         ",
                                   ticks,
                                   tb->valid,
                                   1);
                    equality_print((char *)"Div By Zero   ",
                                   ticks,
                                   tb->div_by_zero,
                                   0);

                    switch (op)
                    {
                    case 0:
                        equality_print((char *)"Result (U / U)",
                                       ticks,
                                       tb->quotient,
                                       (unsigned)tb->dividend / (unsigned)tb->divisor);
                        equality_print((char *)"Result (U % U)",
                                       ticks,
                                       tb->remainder,
                                       (unsigned)tb->dividend % (unsigned)tb->divisor);
                        break;
                        break;
                    case 1:
                        equality_print((char *)"Result (S / S)",
                                       ticks,
                                       tb->quotient,
                                       (signed)tb->dividend / (signed)tb->divisor);
                        equality_print((char *)"Result (S % S)",
                                       ticks,
                                       tb->remainder,
                                       (signed)tb->dividend % (signed)tb->divisor);
                        break;
                    }
                }

                tick(tb, tfp);
                equality_print((char *)"Valid         ",
                               ticks,
                               tb->valid,
                               0);

                ticks += 1;
            }
        }
    }

    final_print(module);

    tfp->close();

    uint64_t pass, fail;
    get_counts(&pass, &fail);
    delete tb;
    return (fail != 0) ? 1 : 0;
}
