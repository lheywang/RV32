#include "Vsrt.h" // Generated by Verilator
#include "verilated.h"

#include "testbench.h"

unsigned int input1[20] = {10, 100, 1000, 0xFFFFFFFF, 0, 8, 2, 17, 29, 33, 59, 87, 453610452, 452135, 125245454, 47, 123, 789, 456, 20};
unsigned int input2[20] = {3, 5, 7, 9, 22, 0xFFFFFFFF, 21, 37, 49, 11345678, 0xAAAAAAAA, 0x55555555, 456, 123, 789, 741, 852, 963, 0, 123};

// Main
int main(int argc, char **argv)
{
    Verilated::commandArgs(argc, argv);
    Testbench<Vsrt> tb("SRT");
    tb.reset();

    for (int op = 0; op < 2; op++)
    {
        switch (op)
        {
        case 0:
            tb.dut->dividend_signed = 0;
            tb.dut->divisor_signed = 0;
            tb.set_case("Unsigned X Unsigned");
            break;
        case 1:
            tb.dut->dividend_signed = 1;
            tb.dut->divisor_signed = 1;
            tb.set_case("Signed X   Signed");
            break;
        }

        // First set of inputs
        for (int i = 0; i < 20; i++)
        {
            for (int ii = 0; ii < 20; ii++)
            {
                // Set inputs
                tb.dut->dividend = input1[i];
                tb.dut->divisor = input2[ii];

                // Start the test
                tb.stick();
                tb.dut->start = 1;
                tb.stick();
                tb.dut->start = 0;

                tb.run_until(&tb.dut->valid, 1);

                if (tb.dut->divisor == 0)
                {
                    tb.check_equality((unsigned int)tb.dut->div_by_zero, (unsigned int)1, "Div By Zero");
                    tb.check_equality((unsigned int)tb.dut->quotient, (unsigned int)0xFFFFFFFF, "Result (NULL)");
                }
                else
                {
                    tb.check_equality((unsigned int)tb.dut->div_by_zero, (unsigned int)0, "Div By Zero");

                    switch (op)
                    {
                    case 0:
                        tb.check_equality((unsigned int)tb.dut->quotient, (unsigned int)((unsigned)tb.dut->dividend / (unsigned)tb.dut->divisor), "Result (U / U)");
                        tb.check_equality((unsigned int)tb.dut->remainder, (unsigned int)((unsigned)tb.dut->dividend % (unsigned)tb.dut->divisor), "Result (U % U)");
                        break;
                    case 1:
                        tb.check_equality((unsigned int)tb.dut->quotient, (unsigned int)((signed)tb.dut->dividend / (signed)tb.dut->divisor), "Result (S / S)");
                        tb.check_equality((unsigned int)tb.dut->remainder, (unsigned int)((signed)tb.dut->dividend % (signed)tb.dut->divisor), "Result (S % S)");
                        break;
                    }
                }

                tb.tick();
                tb.check_equality((unsigned int)tb.dut->valid, (unsigned int)0, "Valid");
                tb.increment_cycles();
            }
        }
    }

    return tb.get_return();
}
