#include "Valu1.h" // Generated by Verilator
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>

#include "colors.h"
#include "utils.h"

int inputs1[5] = {10, 32, 48, 64, 1024};
int inputs2[5] = {10, -32, 48, 64, 1024};

char *module = (char *)"ALU1";

// Main
int main(int argc, char **argv)
{
    Verilated::commandArgs(argc, argv);

    // Instantiate model
    Valu1 *tb = new Valu1;

    // Setup waveform tracing
    Verilated::traceEverOn(true);
    VerilatedVcdC *tfp = new VerilatedVcdC;
    tb->trace(tfp, 99);
    tfp->open("simout/alu1.vcd");

    initial_print(module);

    // Reset sequence
    tb->rst_n = 0;
    stick(tb, tfp);
    tb->rst_n = 1;
    stick(tb, tfp);
    stick(tb, tfp);
    stick(tb, tfp);

    int cycle = 0;

    // Formal calculation test
    for (int i = 5; i < 13; i++)
    {
        tb->cmd = i;
        tb->addr = 0x00001FFF;
        tb->imm = 0x00001FFF;

        for (int ii = 0; ii < 5; ii++)
        {
            for (int iii = 0; iii < 5; iii++)
            {
                cycle += 1;
                tb->arg0 = (uint32_t)inputs1[ii];
                tb->arg1 = (uint32_t)inputs2[iii];
                tick(tb, tfp);
                tick(tb, tfp);

                equality_print((char *)"Busy", cycle, tb->busy, 1);
                equality_print((char *)"Valid", cycle, tb->valid, 1);

                switch (i)
                {
                case 5: // SLT
                    equality_print((char *)"SLT - res", cycle, tb->res, (static_cast<int32_t>(inputs1[ii]) < static_cast<int32_t>(inputs2[iii])) ? 1 : 0);
                    equality_print((char *)"SLT - req", cycle, tb->req, 0);
                    break;

                case 6: // SLTU
                    equality_print((char *)"SLTU - res", cycle, tb->res, (static_cast<uint32_t>(inputs1[ii]) < static_cast<uint32_t>(inputs2[iii]) ? 1 : 0));
                    equality_print((char *)"SLTU - req", cycle, tb->req, 0);
                    break;

                case 7: // BEQ
                    equality_print((char *)"BEQ - res", cycle, tb->res, 16382);
                    equality_print((char *)"BEQ - req", cycle, tb->req, ((static_cast<int32_t>(inputs1[ii]) == static_cast<int32_t>(inputs2[iii])) ? 1 : 0));
                    break;

                case 8: // BNE
                    equality_print((char *)"BNE - res", cycle, tb->res, 16382);
                    equality_print((char *)"BNE - req", cycle, tb->req, ((static_cast<int32_t>(inputs1[ii]) == static_cast<int32_t>(inputs2[iii])) ? 0 : 1));
                    break;

                case 9: // BLT
                    equality_print((char *)"BLT - res", cycle, tb->res, 16382);
                    equality_print((char *)"BLT - req", cycle, tb->req, ((static_cast<int32_t>(inputs1[ii]) < static_cast<int32_t>(inputs2[iii])) ? 1 : 0));
                    break;
                case 10: // BGE
                    equality_print((char *)"BGE - res", cycle, tb->res, 16382);
                    equality_print((char *)"BGE - req", cycle, tb->req, ((static_cast<int32_t>(inputs1[ii]) >= static_cast<int32_t>(inputs2[iii])) ? 1 : 0));
                    break;
                case 11: // BLTU
                    equality_print((char *)"BLTU - res", cycle, tb->res, 16382);
                    equality_print((char *)"BLTU - req", cycle, tb->req, (static_cast<uint32_t>(inputs1[ii]) < static_cast<uint32_t>(inputs2[iii])) ? 1 : 0);
                    break;                
                case 12: // BGEU
                    equality_print((char *)"BGEU - res", cycle, tb->res, 16382);
                    equality_print((char *)"BGEU - req", cycle, tb->req, (static_cast<uint32_t>(inputs1[ii]) >= static_cast<uint32_t>(inputs2[iii])) ? 1 : 0);
                    break;
                }

                tb->clear = 1;
            }
        }
    }

    final_print(module);

    tfp->close();

    uint64_t fail, pass;
    get_counts(&pass, &fail);

    delete tb;
    return (fail != 0) ? 1 : 0;
}
