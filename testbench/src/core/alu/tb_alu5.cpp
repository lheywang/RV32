#include "Valu5.h" // Generated by Verilator
#include "verilated.h"

#include "testbench.h"

/*
 *  Note for the future :
 *
 *  The testbench does test the logic within a certain timing, that
 *  has not been fixed with the RAM IP at this point.
 *
 *  For the future, the ALU need some timings arrangements, and thus,
 *  the testbench may fail. Just adapt the tb.tick() functions
 *  calls accordingly.
 */

static inline int32_t sext8(uint32_t x)
{
    return (int32_t)((int8_t)(x & 0xFF));
}

static inline int32_t sext16(uint32_t x)
{
    return (int32_t)((int16_t)(x & 0xFFFF));
}

unsigned writedata[10] = {
    0xFFFFFFFF, 0x55555555, 0x12345678, 0x9ABCDEF0, 0x11111111,
    0x33333333, 0xdeadbeef, 0xcafecafe, 0xbeefdead, 0xAAAAAAAA // Buffer of data to be used as IO
};

// Main
int main(int argc, char **argv)
{
    Verilated::commandArgs(argc, argv);
    Testbench<Valu5> tb("ALU5");
    tb.reset();

    tb.dut->i_rd = 0x1F;
    tb.dut->arg0 = 0x1000F0F0;

    int cycle = 0;

    // Performing writes
    for (int i = 27; i < 30; i++)
    {
        tb.dut->cmd = i;

        switch (i)
        {
        case 27: 
            tb.set_case("SB");
            break;
        case 28:
            tb.set_case("SH");
            break;
        case 29:
            tb.set_case("SW");
            break;
        }

        // Iterate over some data
        for (int ii = 0; ii < 10; ii++)
        {
            // First, apply signals
            tb.dut->arg1 = writedata[ii];

            // Iterate over sub-addresses
            for (int iii = 0; iii < 4; iii++)
            {
                // We want a constant address, and only move the byte enable signals
                int target_addr = tb.dut->arg0;
                tb.dut->imm = iii;

                tb.tick();
                tb.tick();

                tb.check_equality((unsigned int)tb.dut->mem_addr, (unsigned int)target_addr, "Write-memaddr");
                tb.check_equality((unsigned int)tb.dut->mem_we, (unsigned int)1, "Write-we");
                tb.check_equality((unsigned int)tb.dut->mem_req, (unsigned int)1, "Write-req");
                tb.check_equality((unsigned int)tb.dut->busy, (unsigned int)1, "Write-busy");

                switch (i)
                {
                case 27: // SB
                    switch (iii)
                    {
                    case 0:
                        tb.check_equality((unsigned int)tb.dut->mem_wdata, (unsigned int)(writedata[ii] & 0x000000FF), "Write-wdata");
                        break;

                    case 1:
                        tb.check_equality((unsigned int)tb.dut->mem_wdata, (unsigned int)(writedata[ii] & 0x000000FF) << 8, "Write-wdata");
                        break;

                    case 2:
                        tb.check_equality((unsigned int)tb.dut->mem_wdata, (unsigned int)(writedata[ii] & 0x000000FF) << 16, "Write-wdata");
                        break;

                    case 3:
                        tb.check_equality((unsigned int)tb.dut->mem_wdata, (unsigned int)(writedata[ii] & 0x000000FF) << 24, "Write-wdata");
                        ;
                        break;
                    }
                    break;

                case 28: // SH
                    switch (iii)
                    {
                    case 0:
                    case 1:
                        tb.check_equality((unsigned int)tb.dut->mem_wdata, (unsigned int)writedata[ii] & 0x0000FFFF, "Write-wdata");
                        break;

                    case 2:
                    case 3:
                        tb.check_equality((unsigned int)tb.dut->mem_wdata, (unsigned int)(writedata[ii] & 0x0000FFFF) << 16, "Write-wdata");
                        break;
                    }
                    break;

                case 29: // SW
                    tb.check_equality((unsigned int)tb.dut->mem_wdata, (unsigned int)writedata[ii], "Write-wdata");
                    break;
                }

                tb.tick();

                tb.check_equality((unsigned int)tb.dut->valid, (unsigned int)1, "Write-valid");
                tb.check_equality((unsigned int)tb.dut->res, (unsigned int)0, "Write-res");
                tb.check_equality((unsigned int)tb.dut->req, (unsigned int)0, "Write-req");

                tb.dut->clear = 1;
                tb.tick();
                tb.dut->clear = 0;

                tb.increment_cycles();
            }
        }
    }

    tb.dut->i_rd = 0x1F;
    tb.dut->arg0 = 0x1000F0F0;

    // Performing reads
    for (int i = 30; i < 35; i++)
    {
        tb.dut->cmd = i;

        switch (i)
        {
        case 30: 
            tb.set_case("LB");
            break;
        case 31:
            tb.set_case("LH");
            break;
        case 32:
            tb.set_case("LW");
            break;
        case 33:
            tb.set_case("LBU");
            break;
        case 34:
            tb.set_case("LHU");
            break;
        }

        // Iterate over some data
        for (int ii = 0; ii < 10; ii++)
        {
            // First, apply signals
            tb.dut->mem_rdata = writedata[ii];

            // Iterate over sub-addresses
            for (int iii = 0; iii < 4; iii++)
            {

                // We want a constant address, and only move the byte enable signals
                int target_addr = tb.dut->arg0;

                tb.dut->imm = iii;
                tb.dut->clear = 0;

                tb.tick();
                tb.tick();

                tb.check_equality((unsigned int)tb.dut->mem_addr, (unsigned int)target_addr, "Read-memaddr");
                tb.check_equality((unsigned int)tb.dut->mem_we, (unsigned int)0, "Read-we");
                tb.check_equality((unsigned int)tb.dut->mem_req, (unsigned int)1, "Read-req");
                tb.check_equality((unsigned int)tb.dut->busy, (unsigned int)1, "Read-busy");

                tb.tick();
                tb.dut->clear = 1;

                switch (i)
                {
                case 30: // LB
                    switch (iii)
                    {
                    case 0:
                        tb.check_equality((unsigned int)tb.dut->res, (unsigned int)sext8((writedata[ii] >> 0) & 0x000000FF), "Read-res");
                        break;

                    case 1:
                        tb.check_equality((unsigned int)tb.dut->res, (unsigned int)sext8((writedata[ii] >> 8) & 0x000000FF), "Read-res");
                        break;

                    case 2:
                        tb.check_equality((unsigned int)tb.dut->res, (unsigned int)sext8((writedata[ii] >> 16) & 0x000000FF), "Read-res");
                        break;

                    case 3:
                        tb.check_equality((unsigned int)tb.dut->res, (unsigned int)sext8((writedata[ii] >> 24) & 0x000000FF), "Read-res");
                        break;
                    }
                    break;

                case 31: // LH
                    switch (iii)
                    {
                    case 0:
                    case 1:
                        tb.check_equality((unsigned int)tb.dut->res, (unsigned int)sext16((writedata[ii] >> 0) & 0x0000FFFF), "Read-res");
                        break;

                    case 2:
                    case 3:
                        tb.check_equality((unsigned int)tb.dut->res, (unsigned int)sext16((writedata[ii] >> 16) & 0x0000FFFF), "Read-res");
                        break;
                    }
                    break;

                case 32: // LW
                    tb.check_equality((unsigned int)tb.dut->res, (unsigned int)writedata[ii], "Read-res");
                    break;

                case 33: // LBU
                    switch (iii)
                    {
                    case 0:
                        tb.check_equality((unsigned int)tb.dut->res, (unsigned int)(writedata[ii] >> 0) & 0x000000FF, "Read-res");
                        break;

                    case 1:
                        tb.check_equality((unsigned int)tb.dut->res, (unsigned int)(writedata[ii] >> 8) & 0x000000FF, "Read-res");
                        break;

                    case 2:
                        tb.check_equality((unsigned int)tb.dut->res, (unsigned int)(writedata[ii] >> 16) & 0x000000FF, "Read-res");
                        break;

                    case 3:
                        tb.check_equality((unsigned int)tb.dut->res, (unsigned int)(writedata[ii] >> 24) & 0x000000FF, "Read-res");
                        break;
                    }
                    break;

                case 34: // LHU
                    switch (iii)
                    {
                    case 0:
                    case 1:
                        tb.check_equality((unsigned int)tb.dut->res, (unsigned int)writedata[ii] & 0x0000FFFF, "Read-res");
                        break;

                    case 2:
                    case 3:
                        tb.check_equality((unsigned int)tb.dut->res, (unsigned int)(writedata[ii] >> 16) & 0x0000FFFF, "Read-res");
                        break;
                    }
                    break;
                }

                tb.check_equality((unsigned int)tb.dut->valid, (unsigned int)1, "Read-valid");
                tb.tick();

                cycle += 1;
            }
        }
    }

    tb.dut->mem_err = 1;
    tb.dut->imm = 0;
    tb.dut->clear = 0;

    tb.tick();
    tb.tick();
    tb.tick();
    tb.tick();

    // Checking that the ALU does perform the feedback of errors
    tb.set_case("Error feedback (out)");
    for (int i = 27; i < 35; i++)
    {
        tb.dut->cmd = 30;

        tb.tick();
        tb.tick();
        tb.tick();
        tb.tick();
        tb.tick();
        tb.tick();

        tb.check_equality((unsigned int)tb.dut->o_error, (unsigned int)1, "Read-o_error");

        tb.tick();
        tb.dut->clear = 1;
        tb.tick();
        tb.dut->clear = 0;

        cycle += 1;
    }

    tb.dut->mem_err = 0;
    tb.dut->clear = 0;

    // Checking that the ALU does perform the feedback of errors
    tb.set_case("Error feedback (in)");
    for (int i = 10; i < 14; i++)
    {
        tb.dut->cmd = 0;

        tb.dut->mem_err = 0;
        tb.dut->imm = 0;

        tb.tick();
        tb.tick();
        tb.tick();
        tb.tick();

        tb.check_equality((unsigned int)tb.dut->i_error, (unsigned int)1, "Read-i_error");

        tb.tick();
        tb.dut->clear = 1;
        tb.tick();
        tb.dut->clear = 0;

        tb.increment_cycles();
    }

    return tb.get_return();
}
