#include "Valu5.h" // Generated by Verilator
#include "verilated.h"

#include "testbench.h"

/*
 *  Note for the future :
 *
 *  The testbench does test the logic within a certain timing, that
 *  has not been fixed with the RAM IP at this point.
 *
 *  For the future, the ALU need some timings arrangements, and thus,
 *  the testbench may fail. Just adapt the tb.tick() functions
 *  calls accordingly.
 */

static inline int32_t sext8(uint32_t x)
{
    return (int32_t)((int8_t)(x & 0xFF));
}

static inline int32_t sext16(uint32_t x)
{
    return (int32_t)((int16_t)(x & 0xFFFF));
}

unsigned writedata[10] = {
    0xFFFFFFFF, 0x55555555, 0x12345678, 0x9ABCDEF0, 0x11111111,
    0x33333333, 0xdeadbeef, 0xcafecafe, 0xbeefdead, 0xAAAAAAAA // Buffer of data to be used as IO
};

// Main
int main(int argc, char **argv)
{
    Verilated::commandArgs(argc, argv);
    Testbench<Valu5> tb("ALU5");
    tb.reset();

    tb.dut->i_rd = 0x1F;
    tb.dut->arg0 = 0x1000F0F0;

    // Performing writes
    for (auto op : EnumRange<alu_commands_t>(alu_commands_t::c_SB, alu_commands_t::c_SW))
    {
        tb.set_case_enum("Write", op);
        tb.dut->cmd = op;

        // Iterate over some data
        for (int ii = 0; ii < 10; ii++)
        {
            // First, apply signals
            tb.dut->arg1 = writedata[ii];

            // Iterate over sub-addresses
            for (int iii = 0; iii < 4; iii++)
            {
                // We want a constant address, and only move the byte enable signals
                int target_addr = tb.dut->arg0;
                tb.dut->imm = iii;

                tb.tick();
                tb.tick();

                tb.check_equality((unsigned int)tb.dut->mem_addr, (unsigned int)target_addr,
                                  "Write-memaddr");
                tb.check_equality((unsigned int)tb.dut->mem_we, (unsigned int)1, "Write-we");
                tb.check_equality((unsigned int)tb.dut->mem_req, (unsigned int)1, "Write-req");
                tb.check_equality((unsigned int)tb.dut->busy, (unsigned int)1, "Write-busy");

                switch (op)
                {
                case alu_commands_t::c_SB:
                    tb.check_equality((unsigned int)tb.dut->mem_wdata,
                                      (unsigned int)(writedata[ii] & 0x000000FF) << (iii * 8),
                                      "Write-wdata");
                    break;

                case alu_commands_t::c_SH:
                    tb.check_equality((unsigned int)tb.dut->mem_wdata,
                                      (unsigned int)(writedata[ii] & 0x0000FFFF)
                                          << ((iii >> 1) * 16),
                                      "Write-wdata");
                    break;

                case alu_commands_t::c_SW:
                    tb.check_equality((unsigned int)tb.dut->mem_wdata, (unsigned int)writedata[ii],
                                      "Write-wdata");
                    break;

                default:
                    break;
                }

                tb.tick();

                tb.check_equality((unsigned int)tb.dut->valid, (unsigned int)1, "Write-valid");
                tb.check_equality((unsigned int)tb.dut->res, (unsigned int)0, "Write-res");
                tb.check_equality((unsigned int)tb.dut->req, (unsigned int)0, "Write-req");

                tb.dut->clear = 1;
                tb.tick();
                tb.dut->clear = 0;

                tb.increment_cycles();
            }
        }
    }

    tb.dut->i_rd = 0x1F;
    tb.dut->arg0 = 0x1000F0F0;

    // Performing reads
    for (auto op : EnumRange<alu_commands_t>(alu_commands_t::c_LB, alu_commands_t::c_LHU))
    {
        tb.dut->cmd = op;
        tb.set_case_enum("Read", op);

        // Iterate over some data
        for (int ii = 0; ii < 10; ii++)
        {
            // First, apply signals
            tb.dut->mem_rdata = writedata[ii];

            // Iterate over sub-addresses
            for (int iii = 0; iii < 4; iii++)
            {

                // We want a constant address, and only move the byte enable signals
                int target_addr = tb.dut->arg0;

                tb.dut->imm = iii;
                tb.dut->clear = 0;

                tb.tick();
                tb.tick();

                tb.check_equality((unsigned int)tb.dut->mem_addr, (unsigned int)target_addr,
                                  "Read-memaddr");
                tb.check_equality((unsigned int)tb.dut->mem_we, (unsigned int)0, "Read-we");
                tb.check_equality((unsigned int)tb.dut->mem_req, (unsigned int)1, "Read-req");
                tb.check_equality((unsigned int)tb.dut->busy, (unsigned int)1, "Read-busy");

                tb.tick();
                tb.dut->clear = 1;

                switch (op)
                {
                case alu_commands_t::c_LB:
                    tb.check_equality(
                        (unsigned int)tb.dut->res,
                        (unsigned int)sext8((writedata[ii] >> (iii * 8)) & 0x000000FF), "Read-res");
                    break;

                case alu_commands_t::c_LH:
                    tb.check_equality(
                        (unsigned int)tb.dut->res,
                        (unsigned int)sext16((writedata[ii] >> ((iii >> 1) * 16)) & 0x0000FFFF),
                        "Read-res");
                    break;

                case alu_commands_t::c_LW:
                    tb.check_equality((unsigned int)tb.dut->res, (unsigned int)writedata[ii],
                                      "Read-res");
                    break;

                case alu_commands_t::c_LBU:
                    tb.check_equality((unsigned int)tb.dut->res,
                                      (unsigned int)(writedata[ii] >> (iii * 8) & 0x000000FF),
                                      "Read-res");
                    break;

                case alu_commands_t::c_LHU:
                    tb.check_equality(
                        (unsigned int)tb.dut->res,
                        (unsigned int)(writedata[ii] >> ((iii >> 1) * 16) & 0x0000FFFF),
                        "Read-res");
                    break;

                default:
                    break;
                }

                tb.check_equality((unsigned int)tb.dut->valid, (unsigned int)1, "Read-valid");
                tb.tick();

                tb.increment_cycles();
            }
        }
    }

    tb.dut->mem_err = 1;
    tb.dut->imm = 0;
    tb.dut->clear = 0;

    tb.run_for(4);

    // Checking that the ALU does perform the feedback of errors
    tb.set_case("Error feedback (out)");
    for (int i = 27; i < 35; i++)
    {
        tb.dut->cmd = 30;

        tb.run_for(6);

        tb.check_equality((unsigned int)tb.dut->o_error, (unsigned int)1, "Read-o_error");

        tb.clear();
        tb.increment_cycles();
    }

    tb.dut->mem_err = 0;
    tb.dut->clear = 0;

    // Checking that the ALU does perform the feedback of errors
    tb.set_case("Error feedback (in)");
    for (int i = 0; i < 4; i++)
    {
        tb.dut->cmd = 0;

        tb.dut->mem_err = 0;
        tb.dut->imm = 0;

        tb.run_for(6);

        tb.check_equality((unsigned int)tb.dut->i_error, (unsigned int)1, "Read-i_error");

        tb.clear();
        tb.increment_cycles();
    }

    return tb.get_return();
}
