#include "Vprediction.h" // Generated by Verilator
#include "verilated.h"

#include "testbench.h"

// Main
int main(int argc, char **argv)
{
    Verilated::commandArgs(argc, argv);
    Testbench<Vprediction> tb("Prediction");
    tb.reset();

    int base = 0x10001FFF;

    // Ensuring that the adder works correctly
    for (auto op : EnumRange<opcodes_t>(opcodes_t::i_JAL, opcodes_t::i_JALR))
    {
        tb.set_case_enum("Always", op);

        tb.dut->addr_in = base;
        tb.dut->actual_addr = base + 0x8;
        tb.dut->actual_imm = 0x00000100;
        tb.dut->actual_instr = op;
        tb.dut->predict_ok = 0;
        tb.dut->mispredict = 0;

        tb.run_until(&tb.dut->PC_write, 1);

        tb.check_equality((int)tb.dut->PC_value, (int)(base + 0x8 + 0x00000100), "jump value");
        tb.check_equality((int)tb.dut->addr_out, (int)(base + 0x8 + 0x00000100), "addr out");
        tb.check_equality((int)tb.dut->PC_write, (int)1, "PC_write");

        tb.tick();

        tb.check_equality((int)tb.dut->PC_write, (int)0, "PC_write");
        tb.check_equality((int)tb.dut->PC_value, (int)0, "jump value");
        tb.check_equality((int)tb.dut->addr_out, (int)base, "addr out");
    }

    // adding some cooldown to make debugging easier
    tb.dut->actual_instr = 0;
    tb.run_for(8);

    // Second tests, we need to check the dynamic behavior of the BPU
    for (auto op : EnumRange<opcodes_t>(opcodes_t::i_BEQ, opcodes_t::i_BGEU))
    {
        tb.set_case_enum("Increment", op);

        tb.reset();
        tb.dut->addr_in = base;
        tb.dut->actual_addr = base + 0x8;
        tb.dut->actual_imm = 0x00000100;
        tb.dut->actual_instr = op;

        // Looping over some positive predictions results
        for (int k = 0; k < 4; k += 1)
        {

            // Branch shall NOT be taken
            if (k < 2)
            {
                tb.check_equality((int)tb.dut->PC_value, (int)0, "jump value");
                tb.check_equality((int)tb.dut->PC_write, (int)0, "PC_write");
                tb.check_equality((int)tb.dut->addr_out, (int)base, "addr out");
            }
            else
            {
                tb.check_equality((int)tb.dut->PC_value, (int)(base + 0x8 + 0x00000100),
                                  "jump value");
                tb.check_equality((int)tb.dut->PC_write, (int)1, "PC_write");
                tb.check_equality((int)tb.dut->addr_out, (int)(base + 0x8 + 0x00000100),
                                  "addr out");
            }

            tb.tick();

            tb.check_equality((int)tb.dut->PC_write, (int)0, "PC_write2");
            tb.check_equality((int)tb.dut->PC_value, (int)0, "jump value2");
            tb.check_equality((int)tb.dut->addr_out, (int)base, "addr out2");

            tb.dut->predict_ok = 1;
            tb.tick();
            tb.dut->predict_ok = 0;
            tb.tick();
        }
    }
    tb.dut->actual_instr = 0;

    // Third test, testing counter decrementation
    for (auto op : EnumRange<opcodes_t>(opcodes_t::i_BEQ, opcodes_t::i_BGEU))
    {
        tb.reset();
        tb.dut->addr_in = base;
        tb.dut->actual_addr = base + 0x8;
        tb.dut->actual_imm = 0x00000100;
        tb.set_case_enum("Decrement", op);

        // Setting the counter up to the top
        for (int k = 0; k < 4; k += 1)
        {
            tb.dut->predict_ok = 1;
            tb.tick();
            tb.dut->predict_ok = 0;
            tb.tick();
        }

        tb.dut->actual_instr = op;

        // Looping over some positive predictions results
        for (int k = 0; k < 4; k += 1)
        {

            // Branch shall NOT be taken
            if (k < 2)
            {
                tb.check_equality((int)tb.dut->PC_value, (int)(base + 0x8 + 0x00000100),
                                  "jump value");
                tb.check_equality((int)tb.dut->PC_write, (int)1, "PC_write");
                tb.check_equality((int)tb.dut->addr_out, (int)(base + 0x8 + 0x00000100),
                                  "addr out");
            }
            else
            {
                tb.check_equality((int)tb.dut->PC_value, (int)0, "jump value");
                tb.check_equality((int)tb.dut->PC_write, (int)0, "PC_write");
                tb.check_equality((int)tb.dut->addr_out, (int)base, "addr out");
            }

            tb.tick();
            tb.tick();

            tb.check_equality((int)tb.dut->PC_write, (int)0, "PC_write2");
            tb.check_equality((int)tb.dut->PC_value, (int)0, "jump value2");
            tb.check_equality((int)tb.dut->addr_out, (int)base, "addr out2");

            tb.dut->mispredict = 1;
            tb.tick();
            tb.dut->mispredict = 0;
            tb.tick();
        }
    }

    return tb.get_return();
}
