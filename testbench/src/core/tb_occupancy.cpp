#include "Voccupancy.h" // Generated by Verilator
#include "verilated.h"

#include "testbench.h"

// Main
int main(int argc, char **argv)
{
    Verilated::commandArgs(argc, argv);
    Testbench<Voccupancy> tb("Occupancy");
    tb.reset();

    tb.dut->write = 1;
    tb.dut->lock = 1;

    // First, lock some registers
    tb.set_case("Locking (1)");
    for (int i = 1; i < 32; i += 2)
    {
        tb.dut->source1 = 0;
        tb.dut->source2 = 0;
        tb.dut->target = i;
        tb.tick();

        tb.check_equality((unsigned int)tb.dut->exec_ok, (unsigned int)1, "status bit (1)");
        tb.increment_cycles();
    }

    // Then, try to overwrite the same registers (shall be blocked).
    tb.set_case("Locking (2)");
    for (int i = 1; i < 32; i += 2)
    {
        tb.dut->source1 = 0;
        tb.dut->source2 = 0;
        tb.dut->target = i;
        tb.tick();

        tb.check_equality((unsigned int)tb.dut->exec_ok, (unsigned int)0, "status bit (0)");
        tb.increment_cycles();
    }

    tb.dut->lock = 0;
    tb.dut->write = 1;

    // Then, free them
    tb.set_case("Freing (1)");
    for (int i = 1; i < 32; i += 2)
    {
        tb.dut->address = i;
        tb.tick();
        tb.increment_cycles();
    }

    tb.dut->write = 1;
    tb.dut->lock = 1;

    // Finally, relock them
    tb.set_case("Locking (3)");
    for (int i = 1; i < 32; i += 2)
    {
        tb.dut->source1 = 0;
        tb.dut->source2 = 0;
        tb.dut->target = i;
        tb.tick();

        tb.check_equality((unsigned int)tb.dut->exec_ok, (unsigned int)1, "status bit (1)");
        tb.increment_cycles();
    }

    return tb.get_return();
}
