#include "Vcsr.h" // Generated by Verilator
#include "verilated.h"

#include "testbench.h"

unsigned short int addresses[] = {
    0x300, 0x304, 0x305,
    0x340, 0x341, 0x342,
    0x343, 0x344, 0xB00,
    0xB02, 0xB03, 0xB04,
    0xB05, 0xB80, 0xB82,
    0xB83, 0xB84, 0xB85,
    0xF10, 0xF11, 0xF12,
    0xF13, 0xF14 // Written addresses of CSR registers.
};

unsigned int readback[] = {
    0x00007188, 0xFFFF0888, 0xFFFFFF01,
    0xFFFFFFFF, 0xFFFFFFFE, 0x8000001F,
    0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000 // Values that shall be read
};

// Main
int main(int argc, char **argv)
{
    Verilated::commandArgs(argc, argv);
    Testbench<Vcsr> tb("CSR");

    tb.tick();
    tb.tick();

    // Count test
    for (uint64_t k = 0; k < 23; k++)
    {
        // Write some data (and calling tick to register them)
        tb.dut->wa = addresses[k];
        tb.dut->wd = 0xFFFFFFFF;
        tb.dut->we = 1;
        tb.tick();
        tb.dut->we = 0;
        tb.tick(); // Writes are taking two cycles (or 1 CPU cycle).

        tb.dut->ra = addresses[k];
        tb.tick();

        // Read some data (without calling tick but only eval to register them without clock)
        tb.check_equality((unsigned int)tb.dut->rd, (unsigned int)readback[k], "CSR");
        tb.increment_cycles();
    }

    return tb.get_return();
}
