#include "Vdecoder.h" // Generated by Verilator
#include "verilated.h"
#include "verilated_vcd_c.h"
#include <iostream>
#include <iomanip>
#include "colors.h"

// Simulation time
vluint64_t sim_time = 0;
unsigned clkdiv;

int pass;
int fail;

struct decoded
{
    unsigned int rs1;
    unsigned int rs2;
    unsigned int rd;
    unsigned int imm;
    unsigned int opcode;
    unsigned int illegal;
};

unsigned int instructions[]{
    // Loads
    0b0111010'01010'01101'010'01111'01101'11, // LUI
    0b0111010'01010'01101'010'01111'00101'11, // AUIPC

    // Immediates
    0b1111111'11111'00011'000'10000'00100'11,  // ADDI
    0b1111111'11111'00011'010'10000'00100'11,  // SLTI
    0b1111111'11111'00011'011'10000'00100'11,  // SLTIU
    0b1111111'11111'00011'100'10000'00100'11,  // XORI
    0b1111111'11111'00011'110'10000'00100'11,  // ORI
    0b1111111'11111'00011'111'10000'00100'11,  // ANDI
    0b1111111'11111'00011'001'10000'00100'11,  // SLLI
    0b00000'01'11111'00011'101'10000'00100'11, // SRLI
    0b01000'01'11111'00011'101'10000'00100'11, // SRAI

    // Registers
    0b0000000'01111'10001'000'11111'01100'11, // ADD
    0b0100000'01111'10001'000'11111'01100'11, // SUB
    0b0000000'01111'10001'001'11111'01100'11, // SLL
    0b0000000'01111'10001'010'11111'01100'11, // SLT
    0b0000000'01111'10001'011'11111'01100'11, // SLTU
    0b0000000'01111'10001'100'11111'01100'11, // XOR
    0b0000000'01111'10001'101'11111'01100'11, // SRL
    0b0100000'01111'10001'101'11111'01100'11, // SRA
    0b0000000'01111'10001'110'11111'01100'11, // OR
    0b0000000'01111'10001'111'11111'01100'11, // AND

    // Misc
    0b0000000'00000'00000'000'00000'00011'11, // FENCE

    // Jumps
    0b0111111'00111'00110'000'11111'11000'11, // BEQ
    0b0111111'00111'00110'001'11111'11000'11, // BNE
    0b0111111'00111'00110'100'11111'11000'11, // BLT
    0b0111111'00111'00110'101'11111'11000'11, // BGE
    0b0111111'00111'00110'110'11111'11000'11, // BLTU
    0b0111111'00111'00110'111'11111'11000'11, // BGEU

    // Memory
    0b1111111'11111'00011'000'11111'01000'11, // SB
    0b1111111'11111'00011'001'11111'01000'11, // SH
    0b1111111'11111'00011'010'11111'01000'11, // SW
    0b1111111'11111'00011'000'00001'00000'11, // LB
    0b1111111'11111'00011'001'00001'00000'11, // LH
    0b1111111'11111'00011'010'00001'00000'11, // LW
    0b1111111'11111'00011'100'00001'00000'11, // LBU
    0b1111111'11111'00011'101'00001'00000'11, // LHU

    // Jumps
    0b1111111'11111'11111'111'00011'11011'11, // JAL
    0b1111111'11111'00001'000'00011'11001'11, // JALR

    // Syscalls
    0b0000000'00000'00000'000'00000'11100'11, // ECALL
    0b0000000'00001'00000'000'00000'11100'11, // EBREAK
    0b0011000'00010'00000'000'00000'11100'11, // MRET

    // RV32M
    0b0000001'01111'10001'000'11111'01100'11, // MUL
    0b0000001'01111'10001'001'11111'01100'11, // MULH
    0b0000001'01111'10001'010'11111'01100'11, // MULSHU
    0b0000001'01111'10001'011'11111'01100'11, // MULHU
    0b0000001'01111'10001'100'11111'01100'11, // DIV
    0b0000001'01111'10001'101'11111'01100'11, // DIVU
    0b0000001'01111'10001'110'11111'01100'11, // REM
    0b0000001'01111'10001'111'11111'01100'11, // REMU

    // ZICSR
    0b1111111'11111'11111'001'00001'11100'11, // CSRRW
    0b1111111'11111'11111'010'00001'11100'11, // CSRRS
    0b1111111'11111'11111'011'00001'11100'11, // CSRRC
    0b1111111'11111'11111'101'00001'11100'11, // CSRRWI
    0b1111111'11111'11111'110'00001'11100'11, // CSRRSI
    0b1111111'11111'11111'111'00001'11100'11, // CSRRCI

    // Illegals
    0b1111111'00001'00011'011'11111'01000'11, // (Illegal : SH)
    0b0111111'00111'00110'010'11111'11000'11  // (Illegal : BGE)
};

decoded dinstructions[] = {
    // Loads (0)
    {.rs1 = 0, .rs2 = 0, .rd = 15, .imm = 1957076992, .opcode = 1, .illegal = 0}, // LUI
    {.rs1 = 0, .rs2 = 0, .rd = 15, .imm = 1957076992, .opcode = 2, .illegal = 0}, // AUIPC

    // Immediates (2)
    {.rs1 = 3, .rs2 = 0, .rd = 16, .imm = 0xFFFFFFFF, .opcode = 3, .illegal = 0},  // ADDI
    {.rs1 = 3, .rs2 = 0, .rd = 16, .imm = 0xFFFFFFFF, .opcode = 4, .illegal = 0},  // SLTI
    {.rs1 = 3, .rs2 = 0, .rd = 16, .imm = 0xFFFFFFFF, .opcode = 5, .illegal = 0},  // SLTIU
    {.rs1 = 3, .rs2 = 0, .rd = 16, .imm = 0xFFFFFFFF, .opcode = 6, .illegal = 0},  // XORI
    {.rs1 = 3, .rs2 = 0, .rd = 16, .imm = 0xFFFFFFFF, .opcode = 11, .illegal = 0}, // ORI
    {.rs1 = 3, .rs2 = 0, .rd = 16, .imm = 0xFFFFFFFF, .opcode = 7, .illegal = 0},  // ANDI
    {.rs1 = 3, .rs2 = 0, .rd = 16, .imm = 0xFFFFFFFF, .opcode = 8, .illegal = 0},  // SLLI
    {.rs1 = 3, .rs2 = 0, .rd = 16, .imm = 0x3F, .opcode = 9, .illegal = 0},        // SRLI
    {.rs1 = 3, .rs2 = 0, .rd = 16, .imm = 0x43F, .opcode = 10, .illegal = 0},      // SRAI

    // Registers (b)
    {.rs1 = 17, .rs2 = 15, .rd = 31, .imm = 0, .opcode = 12, .illegal = 0}, // ADD
    {.rs1 = 17, .rs2 = 15, .rd = 31, .imm = 0, .opcode = 13, .illegal = 0}, // SUB
    {.rs1 = 17, .rs2 = 15, .rd = 31, .imm = 0, .opcode = 14, .illegal = 0}, // SLL
    {.rs1 = 17, .rs2 = 15, .rd = 31, .imm = 0, .opcode = 15, .illegal = 0}, // SLT
    {.rs1 = 17, .rs2 = 15, .rd = 31, .imm = 0, .opcode = 16, .illegal = 0}, // SLTU
    {.rs1 = 17, .rs2 = 15, .rd = 31, .imm = 0, .opcode = 17, .illegal = 0}, // XOR
    {.rs1 = 17, .rs2 = 15, .rd = 31, .imm = 0, .opcode = 18, .illegal = 0}, // SRL
    {.rs1 = 17, .rs2 = 15, .rd = 31, .imm = 0, .opcode = 19, .illegal = 0}, // SRA
    {.rs1 = 17, .rs2 = 15, .rd = 31, .imm = 0, .opcode = 20, .illegal = 0}, // OR
    {.rs1 = 17, .rs2 = 15, .rd = 31, .imm = 0, .opcode = 21, .illegal = 0}, // AND

    // Misc (15)
    {.rs1 = 0, .rs2 = 0, .rd = 0, .imm = 0, .opcode = 30, .illegal = 0}, // FENCE

    // Branches (16)
    {.rs1 = 6, .rs2 = 7, .rd = 0, .imm = 0xFFE, .opcode = 31, .illegal = 0}, // BEQ
    {.rs1 = 6, .rs2 = 7, .rd = 0, .imm = 0xFFE, .opcode = 32, .illegal = 0}, // BNE
    {.rs1 = 6, .rs2 = 7, .rd = 0, .imm = 0xFFE, .opcode = 33, .illegal = 0}, // BLT
    {.rs1 = 6, .rs2 = 7, .rd = 0, .imm = 0xFFE, .opcode = 34, .illegal = 0}, // BGE
    {.rs1 = 6, .rs2 = 7, .rd = 0, .imm = 0xFFE, .opcode = 35, .illegal = 0}, // BLTU
    {.rs1 = 6, .rs2 = 7, .rd = 0, .imm = 0xFFE, .opcode = 36, .illegal = 0}, // BGEU

    // Memory (1c)
    {.rs1 = 3, .rs2 = 0x1F, .rd = 0, .imm = 0xFFFFFFFF, .opcode = 42, .illegal = 0}, // SB
    {.rs1 = 3, .rs2 = 0x1F, .rd = 0, .imm = 0xFFFFFFFF, .opcode = 43, .illegal = 0}, // SH
    {.rs1 = 3, .rs2 = 0x1F, .rd = 0, .imm = 0xFFFFFFFF, .opcode = 44, .illegal = 0}, // SW
    {.rs1 = 3, .rs2 = 0, .rd = 1, .imm = 0xFFFFFFFF, .opcode = 37, .illegal = 0},    // LB
    {.rs1 = 3, .rs2 = 0, .rd = 1, .imm = 0xFFFFFFFF, .opcode = 38, .illegal = 0},    // LH
    {.rs1 = 3, .rs2 = 0, .rd = 1, .imm = 0xFFFFFFFF, .opcode = 39, .illegal = 0},    // LW
    {.rs1 = 3, .rs2 = 0, .rd = 1, .imm = 0xFFFFFFFF, .opcode = 40, .illegal = 0},    // LBU
    {.rs1 = 3, .rs2 = 0, .rd = 1, .imm = 0xFFFFFFFF, .opcode = 41, .illegal = 0},    // LHU

    // Jumps (24)
    {.rs1 = 0, .rs2 = 0, .rd = 3, .imm = 0xFFFFFFFE, .opcode = 45, .illegal = 0}, // JAL
    {.rs1 = 1, .rs2 = 0, .rd = 3, .imm = 0xFFFFFFFF, .opcode = 46, .illegal = 0}, // JALR

    // Syscalls (26)
    {.rs1 = 0, .rs2 = 0, .rd = 0, .imm = 0, .opcode = 47, .illegal = 0}, // ECALL
    {.rs1 = 0, .rs2 = 0, .rd = 0, .imm = 0, .opcode = 48, .illegal = 0}, // EBREAK
    {.rs1 = 0, .rs2 = 0, .rd = 0, .imm = 0, .opcode = 49, .illegal = 0}, // MRET

    // RV32M (29)
    {.rs1 = 17, .rs2 = 15, .rd = 31, .imm = 0, .opcode = 22, .illegal = 0}, // MUL
    {.rs1 = 17, .rs2 = 15, .rd = 31, .imm = 0, .opcode = 23, .illegal = 0}, // MULH
    {.rs1 = 17, .rs2 = 15, .rd = 31, .imm = 0, .opcode = 25, .illegal = 0}, // MULHSU
    {.rs1 = 17, .rs2 = 15, .rd = 31, .imm = 0, .opcode = 24, .illegal = 0}, // MULHU
    {.rs1 = 17, .rs2 = 15, .rd = 31, .imm = 0, .opcode = 26, .illegal = 0}, // DIV
    {.rs1 = 17, .rs2 = 15, .rd = 31, .imm = 0, .opcode = 27, .illegal = 0}, // DIVU
    {.rs1 = 17, .rs2 = 15, .rd = 31, .imm = 0, .opcode = 28, .illegal = 0}, // REM
    {.rs1 = 17, .rs2 = 15, .rd = 31, .imm = 0, .opcode = 29, .illegal = 0}, // REMU

    // ZICSR (31)
    {.rs1 = 31, .rs2 = 0, .rd = 1, .imm = 0xFFFFFFFF, .opcode = 50, .illegal = 0}, // CSRRW
    {.rs1 = 31, .rs2 = 0, .rd = 1, .imm = 0xFFFFFFFF, .opcode = 51, .illegal = 0}, // CSRRS
    {.rs1 = 31, .rs2 = 0, .rd = 1, .imm = 0xFFFFFFFF, .opcode = 52, .illegal = 0}, // CSRRC
    {.rs1 = 31, .rs2 = 0, .rd = 1, .imm = 0xFFFFFFFF, .opcode = 53, .illegal = 0}, // CSRRWI
    {.rs1 = 31, .rs2 = 0, .rd = 1, .imm = 0xFFFFFFFF, .opcode = 54, .illegal = 0}, // CSRRSI
    {.rs1 = 31, .rs2 = 0, .rd = 1, .imm = 0xFFFFFFFF, .opcode = 55, .illegal = 0}, // CSRRCI

    // Illegals (37)
    {.rs1 = 3, .rs2 = 1, .rd = 0, .imm = 0xFFFFFFFF, .opcode = 0, .illegal = 1}, // SH Based
    {.rs1 = 6, .rs2 = 7, .rd = 0, .imm = 0xFFE, .opcode = 0, .illegal = 1}       // BGE Based
};

bool compare_decoder(decoded source, decoded reference)
{
    if (reference.rs1 != source.rs1)
        return false;
    if (reference.rs2 != source.rs2)
        return false;
    if (reference.rd != source.rd)
        return false;
    if (reference.imm != source.imm)
        return false;
    if (reference.opcode != source.opcode)
        return false;
    if (reference.illegal != source.illegal)
        return false;
    return true;
}

bool compare_w_print(int cycleID, decoded source, decoded reference)
{
    if (compare_decoder(source, reference))
    {
        std::cout << KGRN
                  << "\t[ PASS ] Cycle "
                  << std::hex
                  << std::setw(4) << cycleID
                  << RST
                  << std::endl;
        pass += 1;
        return true;
    }

    else
    {
        std::cout << KRED
                  << "[ FAIL ] Cycle "
                  << std::hex
                  << std::setw(4) << cycleID
                  << std::endl
                  << "    RS1     (ref | val) : " << std::setw(8) << reference.rs1 << " | " << std::setw(8) << source.rs1 << std::endl
                  << "    RS2     (ref | val) : " << std::setw(8) << reference.rs2 << " | " << std::setw(8) << source.rs2 << std::endl
                  << "    RD      (ref | val) : " << std::setw(8) << reference.rd << " | " << std::setw(8) << source.rd << std::endl
                  << "    IMM     (ref | val) : " << std::setw(8) << reference.imm << " | " << std::setw(8) << source.imm << std::endl
                  << "    OPCODE  (ref | val) : " << std::setw(8) << reference.opcode << " | " << std::setw(8) << source.opcode << std::endl
                  << "    ILLEGAL (ref | val) : " << std::setw(8) << reference.illegal << " | " << std::setw(8) << source.illegal << std::endl
                  << RST
                  << std::endl;
        fail += 1;
        return false;
    }
}

// Toggle clock helper
void tick(Vdecoder *tb, VerilatedVcdC *tfp)
{
    tb->clk = 0;
    tb->eval();
    tfp->dump(sim_time++);
    tb->clk = 1;
    tb->eval();
    tfp->dump(sim_time++);
}

// Main
int main(int argc, char **argv)
{
    Verilated::commandArgs(argc, argv);

    // Instantiate model
    Vdecoder *tb = new Vdecoder;

    // Setup waveform tracing
    Verilated::traceEverOn(true);
    VerilatedVcdC *tfp = new VerilatedVcdC;
    tb->trace(tfp, 99);
    tfp->open("simout/decoder.vcd");

    // Reset sequence
    tb->rst_n = 0;
    tb->clk_en = 1;
    tick(tb, tfp);

    tb->rst_n = 1;
    tick(tb, tfp);

    std::cout << "Starting counter simulation...\n";

    // --- Test 1: Count until overflow ---
    for (int i = 0; i < (sizeof(instructions) / sizeof(unsigned)); i++)
    {
        tb->instruction = instructions[i];
        tb->i_address = 4 * i;
        tick(tb, tfp);
        tick(tb, tfp);
        tick(tb, tfp);

        decoded res = {
            .rs1 = tb->rs1,
            .rs2 = tb->rs2,
            .rd = tb->rd,
            .imm = tb->imm,
            .opcode = tb->opcode,
            .illegal = tb->illegal};

        compare_w_print(i, res, dinstructions[i]);
    }

    std::cout << "Simulation complete."
              << std::endl
              << std::dec << KYEL
              << "--------------------------------------------------------\n"
              << "Results : (PCounter)"
              << "\n--------------------------------------------------------"
              << std::endl
              << KGRN << "\tPass : "
              << std::setw(4) << pass
              << KRED << "\n\tFail : "
              << std::setw(4) << fail
              << RST
              << std::endl;

    if (fail == 0)
        std::cout << KGRN
                  << "Tests passed !"
                  << RST
                  << std::endl;
    else
        std::cout << KRED
                  << "Tests failed !"
                  << RST
                  << std::endl;

    tfp->close();
    delete tb;
    return fail;
}
